---
layout: post
title: '多线程-Thread.start()启动原理'
date: 2024-09-20
author: CJM1024
cover: '/assets/img/title/image.png'
tags: java-多线程
---

## Thread.start()启动原理

---

### 线程启动分析

常见使用：
``` java
new Thread(() -> {
// todo
}).start();
```
为了让大家有一个更直观的认知，我们先站在上帝视角。把这段 Java 的线程代码，到 JDK 方法使用，以及 JVM 的相应处理过程，展示给大家，以方便
我们后续逐步分析。

![线程启动分析](/assets/img/thread/线程启动分析.png)

以上，就是一个线程启动的整体过程分析，会涉及到如下知识点：<br/>
（1）线程的启动会涉及到本地方法（JNI）的调用，也就是那部分 C++ 编写的代码。<br/>
（2）JVM 的实现中会有不同操作系统对线程的统一处理，比如：Win、Linux、Unix。线程的启动会涉及到线程的生命周期状态（RUNNABLE），
以及唤醒操作，所以最终会有回调操作。也就是调用我们的run()方法<br/>
接下来，我们就开始逐步分析每一步源码的执行内容，从而了解线程启动过程。<br/>
1、Thread start UML 图
![Thread start UML](/assets/img/thread/thread_start_UML.png)

2、java层面Thread启动<br>
2.1 start()方法
```java
public synchronized void start() {
    /**
    * This method is not invoked for the main method thread or "system"
    * group threads created/set up by the VM. Any new functionality added
    * to this method in the future may have to also be added to the VM.
    *
    * A zero status value corresponds to state "NEW".
    */
    if (threadStatus != 0)
    throw new IllegalThreadStateException();

    /** Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    group.add(this);

    boolean started = false;
    try {
       start0();
       started = true;
    } finally {
       try {
            if (!started) {
               group.threadStartFailed(this);
            }
       } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
             it will be passed up the call stack */
       }
    }
}
```

线程启动方法 start()，在它的方法英文注释中已经把核心内容描述出来。 Causes this thread to begin execution; the Java Virtual
Machine calls the run method of this thread. 这段话的意思 是：由 JVM 调用此线程的 run 方法，使线程开始执行。其实这就是一个 JVM 的
回调过程，下文源码分析中会讲到<br/>
另外 start() 是一个 synchronized 方法，但为了避免多次调用，在方法中 会由线程状态判断。threadStatus != 0。<br/>
group.add(this)，是把当前线程加入到线程组，ThreadGroup。<br/>
start0()，是一个本地方法，通过 JNI 方式调用执行。这一步的操作才是启动 线程的核心步骤。<br/>

2.2 start0() 本地方法
```java
    // 本地方法 start0
    private native void start0();
    // 注册本地方法
    public class Thread implements Runnable {
    /* Make sure registerNatives is the first thing <clinit> does. */
    private static native void registerNatives();
    static {
        registerNatives();
    }
    // ...
}
```
start0()，是一个本地方法，用于启动线程。<br/>
registerNatives()，这个方法是用于注册线程执行过程中需要的一些本地方 法，比如：start0、isAlive、yield、sleep、interrupt0 等。<br/>
从定义中可以看到，**start0** 方法会执行 **&JVM_StartThread** 方法，最终由 JVM 层面启动线程.<br/>

3、JVM创建线程 <br/>
3.1 JVM_StartThread
```java
JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
JVMWrapper("JVM_StartThread");
JavaThread *native_thread = NULL;
// 创建线程
native_thread = new JavaThread(&thread_entry, sz);
// 启动线程
Thread::start(native_thread);
JVM_END
```
这部分代码比较多，但核心内容主要是**创建线程**和**启动线程**，另外 **&thread_entry** 也是一个方法，如下：<br/>
```java
static void thread_entry(JavaThread* thread, TRAPS) {
HandleMark hm(THREAD);
Handle obj(THREAD, thread->threadObj());
JavaValue result(T_VOID);
JavaCalls::call_virtual(&result,
obj,
KlassHandle(THREAD, SystemDictionary::Thread_klass()),
vmSymbols::run_method_name(),
vmSymbols::void_method_signature(),
THREAD);
}
```

重点，在创建线程引入这个线程入口的方法时，**thread_entry** 中包括了 Java 的回调函数 **JavaCalls::call_virtual**。这个回调函数会由 JVM 调用。<br/>
**vmSymbols::run_method_name()**，就是那个被回调的方法，源码如下：
```java
#define VM_SYMBOLS_DO(template, do_alias)
template(run_method_name, "run")
```
这个 run 就是我们的 Java 程序中会被调用的 run 方法。接下来我们继续按照 代码执行链路，寻找到这个被回调的方法在什么时候调用的。

3.2 JavaThread
```java
native_thread = new JavaThread(&thread_entry, sz);
```
JavaThread 的源码执行内容:
```java
JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :
Thread()
#if INCLUDE_ALL_GCS
, _satb_mark_queue(&_satb_mark_queue_set),
_dirty_card_queue(&_dirty_card_queue_set)
#endif // INCLUDE_ALL_GCS
{
if (TraceThreadEvents) {
tty->print_cr("creating thread %p", this);
}
initialize();
_jni_attach_state = _not_attaching_via_jni;
set_entry_point(entry_point);
// Create the native thread itself.
// %note runtime_23
os::ThreadType thr_type = os::java_thread;
thr_type = entry_point == &compiler_thread_entry ? os::compiler_thread :os::java_
thread;
os::create_thread(this, thr_type, stack_sz);
}
```
ThreadFunction entry_point，就是我们上面的 thread_entry 方法。<br/>
size_t stack_sz，表示进程中已有的线程个数。<br/>
这两个参数，都会传递给 os::create_thread 方法，用于创建线程使用。<br/>

3.3 os::create_thread<br/>


